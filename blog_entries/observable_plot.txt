Working with Observable Plot
#time 05-01-22 12:00
<!-- is there any way to wait for scripts loaded in the body to load? -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.4"></script>
<style>
.graph {
  padding-top: 80px;
  padding-bottom: 80px;
}
.head-section {
  font:  bold italic 18px Georgia,'Times New Roman',serif;
}
.contents {
  font-style: italic;
}
</style>

<!-- TODO: the glitches link doesn't seem to work? Unclear why it goes to the top of the code sample on both chrome and ff -->

<p>Yesterday I wanted to explore how well NBA players played in the first round of
the playoffs. Normally I would reach for d3 to build a visualization of their
performance, but I had been looking for an excuse to play with <a
href="https://github.com/observablehq/plot">Observable Plot</a> so I gave it a
spin.

<p>After I wrote a <a
href="https://github.com/llimllib/nbastats/blob/a641cb2259feb977eef2cd48c044a7645321e502/playoff/data.py">little
data cleaning script</a> that generated <a
href="https://github.com/llimllib/nbastats/blob/cb9551776bcfdce57177d2e569da0e1d70f58890/playoff/data.json">a
json data file</a>, I was ready to give it a go.

<p>This article walks you through how I made three graphics, none of which are finished, but that will maybe be enough to give you an idea of how you might work with observable plot, and whether you want to.

<p>The graphics on this page are not static images, but are generated by the code shown on the page when you load it. (Please <a href="mailto:bill@billmill.org">tell me</a> if something doesn't work.)

<h4 class="head-section">Contents</h3>
<ul class="contents">
  <li><a href="#getting-started">Getting Started</a>
  <li><a href="#more">Let's do something More Complicated</a>
  <li><a href="#glitches">Glitches in the Matrix</a>
  <li><a href="#take2">Take 2</a>
  <li><a href="#overall">Overall Impressions</a>
</ul>

<h4 class="head-section">Figures</h3>
<ul class="contents">
  <li><a href="#graphone">Scatterplot</a>
  <li><a href="#graphtwo">Faceted graphic</a>
  <li><a href="#graphthree">Bar chart</a>
</ul>

<h2 id="getting-started">Getting started</h2>

<p>The <a href="https://github.com/observablehq/plot#installing">installation
instructions</a> provide instructions for installing via yarn or npm,
javascript modules, or via legacy script tags.

<p>Since I'm an old person who doesn't wish to mess around with npm if I can
avoid it, I naturally chose the legacy option that let me get
started quickly.

<p>Here's a simple HTML page that will load the required scripts (d3 is a dependency
of observable plot):

<code lang="html">
<html>
  <head>
    <title>Playoff Performance</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.4"></script>
<script src="index.js"></script>
  </head>
  <body>
  </body>
</html>
</code>

<p>In just a few minutes, by triangulating between the example in the
installation docs and <a
href="https://observablehq.com/@observablehq/plot?collection=@observablehq/plot">the
examples on Observable</a>, I was up and running with a simple scatterplot.

<code lang="js">
async function main() {
  const res = await fetch(`data.json`);
  const stats = await res.json();
  const dotplot = Plot.dot(stats, {
    x: "usg_pct",
    y: "ts_pct",
    stroke: "team",
    title: "name",
  }).plot();
  document.body.append(dotplot);
}

window.addEventListener("DOMContentLoaded", async (_evt) => {
  await main();
});
</code>

<p>Which looks like this:

<div id="graphone" class="graph"></div>
<script>
const dataDownloaded = new Event('dataDownloaded', {bubbles: true});

async function g() {
  const res = await fetch(`https://raw.githubusercontent.com/llimllib/nbastats/cb9551776bcfdce57177d2e569da0e1d70f58890/playoff/data.json`);
  const stats = await res.json();
  window.stats = stats; // let's not re-download it. Save it as a global
  document.dispatchEvent(dataDownloaded);
  const dotplot = Plot.dot(stats, {
    x: "usg_pct",
    y: "ts_pct",
    stroke: "team",
    title: "name",
  }).plot();
  document.body.append(dotplot);
  document.querySelector("#graphone").append(dotplot);
}

window.addEventListener("DOMContentLoaded", async (_evt) => {
  await g();
});
</script>

<p>Hey that's nice! It's not a great graphic, but it was super quick to go from data to a visualization. Much quicker than if I had used plain d3.

<h2 id="more">Let's do something More Complicated</h2>

<p>If a little is good, more must be better, so I wanted to try building something more complicated.

<p>I thought it would be cool to make a grid splitting up the players by team,
and charting the difference in their true shooting percentage (a measure of how
efficiently a player scores) and usage percentage (how often the player shoots
or turns the ball over).

<p>The following graph is hard to read, and I'm not pitching it as a good visualization; I'm just trying to review Observable plot by showing my process of exploring the data. The dot's location is a player's playoff true shooting and usage percentage, and the line leads to their regular season shooting and usage.

<p>A player with a line going up and to the right shot worse and used less possessions in the playoffs than in the regular season; a player with a line going down and to the left shot better and used more.

<p>It took me about an hour to get to this:

<div id="graphtwo" class="graph"></div>
<script>
function gridchart() {
    const players = stats.filter((x) => x.playoff_mpg > 28);

    grid = [
    ["MIA", "ATL", "BOS", "BRK"],
    ["MIL", "CHI", "PHI", "TOR"],
    ["PHO", "NOP", "MEM", "MIN"],
    ["GSW", "DEN", "UTA", "DAL"],
    ];

    // label each player with the appropriate row and column by the team they
    // play on. Extremely inefficient and also takes negligible time. I try to
    // turn off my backend engineering instincts when doing data analysis
    for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
      for (const player of players) {
        if (player.team == grid[i][j]) {
          player.row = i;
          player.col = j;
        }
      }
    }
    }

    const xfield = "playoff_usg_pct";
    const yfield = "playoff_ts_pct";
    const width = 1024;
    const height = 800;
    const ffmt = d3.format(".1f");

    const plot = Plot.plot({
      grid: true,     // show gridlines
      width: width,
      height: height,
      x: {
        domain: d3.extent(players, (d) => d[xfield]),
        nice: true,   // round the scale to nice numbers
        label: "→ usage percentage",
      },
      y: {
        domain: d3.extent(players, (d) => d[yfield]),
        nice: true,
        label: "↑ true shooting",
      },
      facet: {
        data: players,
        x: "col",
        y: "row",
      },
      // "fx" is the x scale for each facet
      fx: {
        axis: null,
      },
      fy: {
        axis: null,
        paddingInner: 0.2,
      },
      marks: [
        Plot.dot(players, {
          x: xfield,
          y: yfield,
          title: "name",
          r: 10,
          fill: (d) => teams[d.team].colors[0],
          stroke: (d) => teams[d.team].colors[1],
          strokeWidth: 5,
        }),
        Plot.link(players, {
          x1: "usg_pct",
          y1: "ts_pct",
          x2: xfield,
          y2: yfield,
        }),
      ],
    });

    // Add labels to the facets. There's no way I can tell to do this within the
    // plot?
    d3.select(plot)
    .selectAll("[aria-label=facet]")
    .append("text")
    .attr("x", width / 8)
    .attr("y", -12)
    .attr("font-weight", "bold")
    .attr("font-size", "1.2em")
    .text((d, i) => grid[d[1]][d[0]]);

    document.querySelector("#graphtwo").append(plot);
}

const teams = {
  ATL: {
    name: "Atlanta Hawks",
    colors: ["#C8102E", "#FDB927", "#000000", "#9EA2A2"],
  },
  BOS: {
    name: "Boston Celtics",
    colors: ["#008348", "#BB9753", "#000000", "#A73832", "#FFFFFF"],
  },
  BRK: { name: "Brooklyn Nets", colors: ["#FFFFFF", "#707271", "#000000"] },
  CHI: { name: "Chicago Bulls", colors: ["#CE1141", "#000000"] },
  DAL: {
    name: "Dallas Mavericks",
    colors: ["#0064B1", "#00285E", "#BBC4CA", "#000000"],
  },
  DEN: {
    name: "Denver Nuggets",
    colors: ["#0E2240", "#FEC524", "#8B2131", "#244289"],
  },
  GSW: { name: "Golden State Warriors", colors: ["#1D428A", "#FDB927"] },
  MEM: {
    name: "Memphis Grizzlies",
    colors: ["#5D76A9", "#12173F", "#707271", "#F5B112"],
  },
  MIA: { name: "Miami Heat", colors: ["#000000", "#98002E", "#F9A01B"] },
  MIL: {
    name: "Milwaukee Bucks",
    colors: ["#00471B", "#EEE1C6", "#0077C0", "#000000", "#FFFFFF"],
  },
  MIN: {
    name: "Minnesota Timberwolves",
    colors: ["#0C2340", "#78BE20", "#236192", "#9EA2A2", "#FFFFFF"],
  },
  NOP: {
    name: "New Orleans Pelicans",
    colors: ["#0A2240", "#8C734B", "#CE0E2D"],
  },
  PHI: {
    name: "Philadelphia 76ers",
    colors: ["#006BB6", "#ED174C", "#C4CED4", "#000000", "#002B5C", "#FFFFFF"],
  },
  PHO: {
    name: "Phoenix Suns",
    colors: ["#1D1160", "#E56020", "#000000", "#63727A", "#F9A01B"],
  },
  TOR: {
    name: "Toronto Raptors",
    colors: ["#CE1141", "#000000", "#393A96", "#B4975A", "#FFFFFF"],
  },
  UTA: { name: "Utah Jazz", colors: ["#002B5C", "#F9A01B", "#00471B"] },
}

window.addEventListener("dataDownloaded", async (_evt) => {
  gridchart();
});
</script>
<code lang="js">
function smallMultipleGraph(stats) {
  const players = stats.filter((x) => x.playoff_mpg > 28);

  grid = [
    ["MIA", "ATL", "BOS", "BRK"],
    ["MIL", "CHI", "PHI", "TOR"],
    ["PHO", "NOP", "MEM", "MIN"],
    ["GSW", "DEN", "UTA", "DAL"],
  ];

  // label each player with the appropriate row and column by the team they
  // play on. Extremely inefficient and also takes negligible time. I try to
  // turn off my backend engineering instincts when doing data analysis
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
      for (const player of players) {
        if (player.team == grid[i][j]) {
          player.row = i;
          player.col = j;
        }
      }
    }
  }

  const xfield = "playoff_usg_pct";
  const yfield = "playoff_ts_pct";
  const width = 1024;
  const height = 800;
  const ffmt = d3.format(".1f");

  const plot = Plot.plot({
    grid: true,     // show gridlines
    width: width,
    height: height,
    x: {
      domain: d3.extent(players, (d) => d[xfield]),
      nice: true,   // round the scale to nice numbers
      label: "→ usage percentage",
    },
    y: {
      domain: d3.extent(players, (d) => d[yfield]),
      nice: true,
      label: "↑ true shooting",
    },
    facet: {
      data: players,
      // Here we use the "col" and "row" variables we added earlier to facet
      // the data the way we wanted
      x: "col",
      y: "row",
    },
    // "fx" is the x scale for each facet
    fx: {
      // it took me forever to figure out that this is how to suppress the
      // facet labels - in our case they're useless, just the row and col
      // variables we add above
      axis: null,
    },
    fy: {
      axis: null,
      paddingInner: 0.2,
    },
    marks: [
      Plot.dot(players, {
        x: xfield,
        y: yfield,
        title: "name",
        r: 10,
        fill: (d) => teams[d.team].colors[0],
        stroke: (d) => teams[d.team].colors[1],
        strokeWidth: 5,
      }),
      // draw the line between regular season and playoff performance
      Plot.link(players, {
        x1: "usg_pct",
        y1: "ts_pct",
        x2: xfield,
        y2: yfield,
      }),
    ],
  });

  // Add labels to the facets. There's no way I can tell to do this within the
  // plot?
  d3.select(plot)
    .selectAll("[aria-label=facet]")
    .append("text")
    .attr("x", width / 8)
    .attr("y", -12)
    .attr("font-weight", "bold")
    .attr("font-size", "1.2em")
    .text((d, i) => grid[d[1]][d[0]]);

  return plot;
}
</code>

<h2 id="glitches">Glitches in the matrix</h2>

<p>I was very impressed with what I was able to do while mostly staying within
the boundaries of the <code class="inline">plot</code> method. Plot let me
express a quite complicated graphic with a tiny bit of pre-processing and then
a mostly declarative description of the marks and axes.

<p>The first thing I found that I couldn't do within the declarative framework
was place a label for each facet. There is a <a
href="https://observablehq.com/@observablehq/plot-text?collection=@observablehq/plot">text
mark</a>, but unfortunately it is only usable within the facet, so the only way
I could figure out to label each facet was to use d3 and place text objects
within the SVG manually.

<p>The next thing I couldn't figure out was how to label the players. I could
have used text marks, but they would have gotten jumbled with the dots on the
graph. What I wanted to do was to make the user able to mouse over them and get
a label; I tried addinggg the <a
href="https://github.com/observablehq/plot#marks">title</a> attribute, but that
didn't seem to work.

<p>Some googling revealed that <a
href="https://github.com/observablehq/plot/issues/4">mouse interaction is still
an open issue</a> on plot, and isn't currently supported. To get my tooltips, I
ended up modifying <a
href="https://observablehq.com/@fil/experimental-plot-tooltip-01">this
observable notebook</a> into <a
href="https://github.com/llimllib/nbastats/blob/cb9551776bcfdce57177d2e569da0e1d70f58890/playoff/tooltip.js">this
javascript file</a>, which took me quite a while to get working and which I
never bothered to fully understand, and doesn't work perfectly.

<p>(You can go <a href="https://llimllib.github.io/nbastats/playoff/graph.html">here</a> to see them in action, though be warned it does not work perfectly - if your browser window doesn't show the full width graphic, the tooltips will be misaligned).

<p>It would be nice if dots were automatically labeled with a tooltip; when I did an <a href="https://twitter.com/llimllib/status/1331628485555724288">exploration into Altair</a> I was grateful that they were put on the graph automatically.

<p>When you reach the boundaries of what can be declared in a declarative
system, things start to get messy.

<h2 id="take2">Take 2</h2>

<p>It took me a while to get that graphic working, but I wasn't very happy with
it as a graphic - it's difficult to understand and I didn't feel like it would
merit me writing up how to interpret it.

<p>(Side note: I've learned that it's very easy to love your own graphics that
you've built, you learn to interpret them as you build them. If they're not
very easy to interpret, when you try to present them to people, they can be
overwhelmed and will often be quite unkind in their criticism. Most people want
<em>very</em> easy to digest graphics, and have strong expectations for the
form they take.)

<p>My next idea was to create a bar chart stacked vertically, with the change
in true shooting represented with a bar to the right if it improved, and a bar
to the left it it got worse. I also wanted to show the change in usage
percentage, so I used the color of the bar to represent that. The unpolished
and unfinished result is below. (Again, it's an interesting but not actually
good visualization that I wouldn't present on its own)

<p>The idea for this one owes to <a href="https://twitter.com/owenlhjphillips">Owen Phillips</a>, whose visualizations are an inspiration to me.

<div id="graphthree" class="graph"></div>
<script>
function bestPlayersGraph() {
  const players = stats.filter((x) => x.playoff_mpg > 30);
  for (const p of players) {
    p.ts_diff = p.playoff_ts_pct - p.ts_pct;
    p.usage_diff = p.playoff_usg_pct - p.usg_pct;
  }

  const sorted = d3.sort(players, (d) => -d.ts_diff);

  const plot = Plot.plot({
    grid: true,
    marginLeft: 130,
    x: {
      label:
        "← decrease · Change in True Shooting percentage in playoffs · increase →",
      labelAnchor: "center",
      domain: d3.extent(sorted, (d) => d.ts_diff),
      nice: true,
      axis: "top",
    },
    y: {
      label: null,
      domain: sorted.map((d) => d.name),
    },
    color: {
      scheme: "rdylgn",
      legend: true,
    },
    marks: [
      Plot.barX(sorted, {
        y: "name",
        x: "ts_diff",
        fill: "usage_diff",
      }),
      Plot.ruleX([0]),
    ],
  });
  document.querySelector("#graphthree").append(plot);
}

window.addEventListener("dataDownloaded", async (_evt) => {
  bestPlayersGraph();
});
</script>

<p>This one actually took me <em>forever</em> to figure out, despite being much
shorter than the previous example, largely because I tried to use facets to
vertically stack the graph rather than just the y scale. I was able to get it
working only once I found <a
href="https://observablehq.com/@observablehq/plot-bar?collection=@observablehq/plot#cell-1069">this
example</a> in the docs.

<code lang="js">
const players = stats.filter((x) => x.playoff_mpg > 30);
for (const p of players) {
  p.ts_diff = p.playoff_ts_pct - p.ts_pct;
  p.usage_diff = p.playoff_usg_pct - p.usg_pct;
}

const sorted = d3.sort(players, (d) => -d.ts_diff);

const plot = Plot.plot({
  grid: true,
  marginLeft: 130,
  x: {
    label:
      "← decrease · Change in True Shooting percentage in playoffs · increase →",
    labelAnchor: "center",
    domain: d3.extent(sorted, (d) => d.ts_diff),
    nice: true,
    axis: "top",
  },
  y: {
    label: null,
    domain: sorted.map((d) => d.name),
  },
  color: {
    scheme: "rdylgn",
    legend: true,
  },
  marks: [
    Plot.barX(sorted, {
      y: "name",
      x: "ts_diff",
      fill: "usage_diff",
    }),
    Plot.ruleX([0]),
  ],
});
</code>

<p>I'm impressed with how compact the final representation for this one is.

<p>My main complaint here is that it seems to be impossible to change the label on the legend. The <a href="https://observablehq.com/@observablehq/plot-bar?collection=@observablehq/plot#cell-1069">docs explain</a> how to generate a separate legend, but not how to change the legend in your graphic. If it's possible, it would be great for the docs to mention it - and if not, to demonstrate how to add the legend generated by <code class="inline">plot.legend</code> to your graphic.

<p>I don't like the way true shooting and usage combine in this graphic, but I think it's headed in the right direction. If I were to continue with it, I might try adding a second column for change in usage, while keeping change in true shooting as it is. At that point, it becomes kind of an annotated table, which is a visualization I've often come back to.

<h2 id="overall">Overall Impressions</h2>

<p>I was impressed with how quickly I was able to get several visualizations up
and running, and how much I was able to express within its framework. With a
little more practice in the library, I think I would favor it for quick and
dirty visualizations.

<p>Once I was trying to polish things up, I found it pretty limiting, so I
think for now I would continue to reach for plain d3 when making graphics for
publication.

<p>For me to be able to use it for more presentational graphics, I'd love to
see it grow advanced labeling capabilities, both with text label placement and
with tooltip integration. I think the legend feature, which is new-ish, could
use some polishing up.

<p>I had a good time creating these graphics, and appreciate all the work that
went into this library and has gone into d3 over the years.

<p>(Go Celtics!)
